#!/usr/bin/env ruby

require 'readline'
require 'io/console'
require_relative "lib/prettyprint"
require_relative "lib/shellprocess"
require_relative "scripting/initializescripts"

#TODO need to take care of a shell that recieves no error
#and has no echo

#puts "h​i\bh"
#puts "h​\x00i\bh"
#puts  "​"
#p  "​"
pp = PrettyPrint.new

#startup scripts to run on 
startup_scripts = create_startup_scripts
pp.print_info("Loaded #{startup_scripts.length} startup scripts\n") if startup_scripts.length > 1
pp.print_info("Loaded #{startup_scripts.length} startup scripts\n") if startup_scripts.length == 1
pp.print_info("Loaded #{startup_scripts.length} startup scripts\n") if startup_scripts.length == 0
#startup regular use scripts
shell_scripts = create_shell_scripts
pp.print_info("Loaded #{shell_scripts.length} shell scripts\n") if shell_scripts.length > 1
pp.print_info("Loaded #{shell_scripts.length} shell scripts\n") if shell_scripts.length == 1
pp.print_info("Loaded #{shell_scripts.length} shell scripts\n") if shell_scripts.length == 0
#initialize shell
#TODO
#this needs to be passed as an arg, for now hardcoded
#temporary switch to develop on kali and mac
mac = 'uname'.include? "Darwin"
remote_shell = ShellProcess.new("nc -lp 4445", pp) unless mac
remote_shell = ShellProcess.new("nc -l 4445", pp) if mac
#wait for connection
remote_shell.verify_connection
#identify prompt
remote_shell.suppress_shell_prompt
#run startup scripts
startup_scripts.each do |script|
  script.run_script(remote_shell, pp)
end

#tab complete
Readline.completion_proc = proc do |s|
  directory_list = Dir.glob("#{s}*")
  if directory_list.size > 0
    directory_list
  else
    Readline::HISTORY.grep(/^#{Regexp.escape(s)}/)
  end
end

while input = Readline.readline("sb \b\b\b", true)
  #Remove blank lines from history
  Readline::HISTORY.pop       if input == ""
  case input
  #when "exit"
  #  break
  when "hist"
    Readline::HISTORY.pop
    puts Readline::HISTORY.to_a
  else
    #check for script keywords
    ran_script = false
    first_word, rest_of_line = input.split(" ", 2)
    shell_scripts.each do |script|
      if first_word == script.keyword then
        ran_script = true
        script.run_script(remote_shell, pp, rest_of_line) 
      end
    end
    remote_shell.input(input)   unless ran_script
  end
end

#all code for smoochbot is written with the assumption 
#that these commands are available to you
#any scenario where these aren't (rbash, etc...) is not accounted for
#as of yet. feel free to submit suggestions/pull requests, I'd be happy
#to expand/fix smoochbot
#all scripts that use commands outside of this search for them before 
#beginning, and abort with appropriate error messages if they can't run
##########################################################################
#bash  defines  the  following built-in commands: :, ., [, alias, bg, bind,
#break, builtin, case, cd, command, compgen, complete, continue, declare, 
#dirs, disown, echo, enable, eval, #exec,  exit,  export,  fc,  fg,  
#getopts, hash, help, history, if, jobs, kill, let, local, logout, popd, 
#printf, pushd, pwd, read,  readonly,  return,  set,  shift,  shopt,  
#source, suspend,  test,  times,  trap,  type, typeset, ulimit, umask, 
#unalias, unset, until, wait, while
##########################################################################




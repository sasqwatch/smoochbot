#!/usr/bin/env ruby

require 'tty-prompt'
require 'open3'
require 'io/console'
require 'readline'
require_relative "prettyprint"
require_relative "shellprocess"

class Smoochbot

  def initialize(shell_process_start_string)
    @pp = PrettyPrint.new
    @lwd = Dir.pwd
    @ttyin, @ttyout, @ttythread = Open3.popen2("./sbtty.rb") 
    @fd_arr = []
    @remote_shell = ShellProcess.new(shell_process_start_string)
    @root = false
    @remote = true
    @local_shell
    @golocalcmd
    @goremotecmd
    @scriptcmd
    @hist_file

    #could use tty here to be fancy :)
    load_config  
    load_history  
    load_listeners
  end

  def beep
    print "\u0007"
  end

  def clear_line
    print "\r\e[J"
  end

  def exit 
    @remote_shell.close
    @local_shell.close
    #signal to sbtty that it has been interrupted
    @ttyin.print "\u0003"
    @ttyin.close
    @ttyout.close
    #join any threads TODO
    @pp.puts("\nGoodbye :)", :pink)
    exit()                          
  end

  def remote?
    @remote
  end

  def local?
    !@remote
  end

  def remote_shell
    @remote_shell
  end

  def local_shell
    @local_shell
  end

  def curr_shell
    @remote ? @remote_shell : @local_shell
  end

  def root_check
    #TODO implement a check for root
    @root = false
  end

  def listeners
    @fd_arr
  end

  def add_to_history(line)
    @hist_file.puts line
  end

  def process_input(input)
    add_to_history(input)
    case input
    when @golocalcmd
      #golocal
      @pp.puts("going local", :yellow)
      @remote = false
    when @goremotecmd
      #goremote
      @pp.puts("going remote", :yellow)
      @remote = true
    when /^#{Regexp.quote(@scriptcmd)}\s+(.+)\s+(\d+)$/
      #script call with timeout
      puts "script timeout placeholder"
    when /^#{Regexp.quote(@scriptcmd)}\s+(.+)\s*$/
      #script call without timeout
      puts "script no timeout placeholder"
    #when nil
      #send enter to shell if it doesn't work by default
    else
      curr_shell.input(input)
    end
  end

  def process_output(stdio)
    banner = curr_shell.listeners.include? stdio
    output = stdio.read_nonblock(2**24) 
    output.gsub!("\n","\r\n") unless output.nil?
    #TODO output banner so the two shell outputs aren't confused
    clear_line
    case stdio
    when @local_shell.stdout
      #local shell stdout
      @pp.print(output)
    when @local_shell.stderr
      #local shell stderr
      @pp.print(output, :red) 
    when @remote_shell.stdout
      #remote shell stdout
      @pp.print(output)
    when @remote_shell.stderr
      #remote shell stderr
      @pp.print(output, :red) 
    end
    #p @tty.reader.history_previous
    #p @tty.reader.history_next
  end

  def load_config
    filename = Dir.home + "/.smoochbot_config"
    if File.exist?(filename) then
      #existing config file, preferred shell is line 1
      File.open(filename).each_line.with_index do |line,index|
        line.chomp!
        case index
        when 0
          #preferred local shell
          @local_shell = ShellProcess.new(line)
        when 1
          #set golocal command
          @golocalcmd = line
        when 2
          #set goremote
          @goremotecmd = line
        when 3
          #set goremote
          @scriptcmd = line
        end
      end
    else
      File.open(filename, "w") do |file|
        @pp.puts("no input validation on this, you can edit this value in",
                 :yellow
                )
        @pp.puts("#{filename}", :yellow)
        @pp.puts("please enter the command to launch your shell of choice",
                 :yellow
                )
        @pp.puts("hint: do not enter smoochbot ;)", :yellow) 
        file.puts STDIN.gets
        @pp.puts("enter the command to go to your local shell", :yellow)
        file.puts STDIN.gets
        @pp.puts("enter the command to go to your remote shell", :yellow)
        file.puts STDIN.gets
        @pp.puts("enter the command to run a script", :yellow)
        file.puts STDIN.gets
      end
    end  
  end

  def load_history
    filename = Dir.home + "/.smoochbot_history"
    if File.exist?(filename) then
      #open history file, load into buffer
      @hist_file = File.open(filename, "a")
    else
      #create history file
      @hist_file = File.open(filename, "a")
      @pp.puts(
               "History file created at #{filename}",
               :yellow
              )
    end
    @hist_file.sync = true
  end

  def load_listeners
    @fd_arr = @remote_shell.listeners + @local_shell.listeners
    @fd_arr << @ttyout 
  end
#Smoochbot
end

#add real args parsing TODO
sb = Smoochbot.new("#{$ARGV[0]}")

#TODO change sticky up and down keys on tty behavior
#TODO add tab complete

selectable = sb.listeners
char_reader, char_writer = IO.pipe
selectable << char_reader
thr = Thread.new {char_writer.print STDIN.getch; char_writer.close}

while true do 
  begin
    #blocking
    ready = IO.select(selectable)
  rescue
    #jumps in here when fd is closed, happens when pipe is closed
    retry
  end  

  readable = ready[0]
  readable.each do |stdio|
    case stdio
    when char_reader
      #tty_reader
      begin
        input = stdio.read_nonblock(2**24)
        @ttyin.print
        #restart tty listener
        thr.join
        selectable.pop.close
        char_reader, char_writer = IO.pipe
        selectable << char_reader
        thr = Thread.new {char_writer.print STDIN.getch; char_writer.close}
      rescue EOFError
        #select heard fd close
        #might be redundant, TODO
      end
    when @ttyout
      input = stdio.read_nonblock(2**24)
      input.strip! unless input.nil?    
      sb.process_input(input)
    else
      #shell output
      sb.process_output(stdio)
    end
  end
end







